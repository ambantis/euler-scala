package net.euler

object ProblemsTo010 {

  // Problem #1 with recursion
  def getSumOfMultiplesA(x: Int, y: Int, limit: Int): Int = {
    def loop(acc: Int, n: Int): Int =
      if (n == limit) acc
      else if (n % x == 0 || n % y == 0) loop(acc + n, n + 1)
      else loop(acc, n + 1)
    loop(0, 0)
  }

  // Problem #1 with fold
  def getSumOfMultiplesB(x: Int, y: Int, limit: Int): Int =
    (0 until limit).filter(a => a % x == 0 || a % y == 0).fold(0)(_ + _)

  // Problem #1 with for
  def getSumOfMultiplesC(x: Int, y: Int, limit: Int): Int =
    (for (a <- (0 until limit) if (a % x == 0 || a % y == 0)) yield a).fold(0)(_ + _)

  // Problem #1 with fold using alternate notation
  def getSumOfMultiplesD(x: Int, y: Int, limit: Int): Int =
    (0 /: (for (a <- (0 until limit) if (a % x == 0 || a % y == 0)) yield a))(_ + _)


  // Problem #2 with recursion

//  Each new term in the Fibonacci sequence is generated by adding the previous two terms.
// By starting with 1 and 2, the first 10 terms will be:
//
//  1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
//
//  By considering the terms in the Fibonacci sequence whose values do not exceed four million,
// find the sum of the even-valued terms.

  def fibo(n: Int): List[Int] = {
    def loop(acc: List[Int]): List[Int] = {
      if (acc.head > n) acc.tail.reverse.tail
      else loop(acc.head + acc.tail.head :: acc)
    }
    loop(List(1, 1))
  }

//  Problem #2 with recursion
  def sumEvenFibonacciA(limit: Int): Int = {
    def loop(acc: List[Int]): Int = {
      if (acc.head > limit) acc.tail.reverse.tail.filter(_ % 2 == 0).fold(0)(_ + _)
      else loop(acc.head + acc.tail.head :: acc)
    }
    loop(List(1,1))
  }

  // Problem #3 Largest Prime Factor
  // The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143 ?
  def largestPrime(num: Int): Int = {
    def loop(acc: List[Int], rem: List[Int]): Int = {
      val p = rem.head
      val pRange: List[Int] = (p * 2 to num by p).toList
      if (rem.tail.isEmpty) rem.head
      else loop(p :: acc, rem.tail.filterNot(pRange.contains(_)))
    }
    loop(Nil, (2 to num).toList)
  }

  def isBigPrime(number: BigInt): Boolean = {
    def loop(i: BigInt, ceiling: BigInt): Boolean =
      if (i > ceiling) true
      else if (number % i == 0) false
      else loop(i+1, ceiling)
    if (number < 0) false
    else if (number < 2) true
    else loop(2, math.sqrt(number.doubleValue()).toInt)
  }

  def nextBigPrime(n: BigInt): BigInt =
    if (isBigPrime(n+1)) n+1
    else nextBigPrime(n+1)

  def largestPrimeFactor(number: BigInt): BigInt = {
    def loop(i: BigInt, lpf: BigInt, rem: BigInt): BigInt = {
      if (i > rem) lpf
      else if (rem % i == 0) loop(i, i, rem / i)
      else loop(nextBigPrime(i), lpf, rem)
    }
    if (number < 2) 1 else loop(2, 0, number)
  }

  def isPrime(number: Int): Boolean = {
    def loop(i: Int, ceiling: Int): Boolean =
      if (i > ceiling) true
      else if (number % i == 0) false
      else loop(i+1, ceiling)
    if (number < 0) false
    else if (number < 2) true
    else loop(2, math.sqrt(number.doubleValue()).toInt)
  }

  def nextPrime(n: Int): Int =
    if (isPrime(n+1)) n+1
    else nextPrime(n+1)

  def primeFactors(number: Int): List[Int] = {
    def loop(i: Int, acc: List[Int], rem: Int): List[Int] =
      if (i > rem) acc
      else if (rem % i == 0) loop(i, i :: acc, rem / i)
      else loop(nextPrime(i), acc, rem)
    if (number < 0) Nil
    else if (number == 0) List(0)
    else if (number == 1) List(1)
    else loop(2, List(), number)
  }

  // Problem #4 Largest palindrome product
  // Find the largest palindrome made from the product of two 3-digit numbers.
  def isPalindrome(n: Int): Boolean = {
    def loop(s: List[Char]): Boolean =
      if (s.tail.isEmpty) true
      else if (s.head == s.last) loop(s.tail.reverse.tail)
      else false
    loop(n.toString.toList)
  }

  def getCombos(x: Int, y: Int): List[Int] = {
    if (x == 0 || y == 0) Nil
    else (x * y) :: getCombos(x - 1, y) ::: getCombos(x, y-1)
  }

  def largestPalindromeProduct(x: Int, y: Int): Int = {
    if (isPalindrome(x * y)) x * y
    else largestPalindromeProduct(x - 1, y - 1)
  }



}