package net.euler

object ProblemsTo010 {

  // Problem #1 with recursion
  def getSumOfMultiplesA(x: Int, y: Int, limit: Int): Int = {
    def loop(acc: Int, n: Int): Int =
      if (n == limit) acc
      else if (n % x == 0 || n % y == 0) loop(acc + n, n + 1)
      else loop(acc, n + 1)
    loop(0, 0)
  }

  // Problem #1 with fold
  def getSumOfMultiplesB(x: Int, y: Int, limit: Int): Int =
    (0 until limit).filter(a => a % x == 0 || a % y == 0).fold(0)(_ + _)

  // Problem #1 with for
  def getSumOfMultiplesC(x: Int, y: Int, limit: Int): Int =
    (for (a <- (0 until limit) if (a % x == 0 || a % y == 0)) yield a).fold(0)(_ + _)

  // Problem #1 with fold using alternate notation
  def getSumOfMultiplesD(x: Int, y: Int, limit: Int): Int =
    (0 /: (for (a <- (0 until limit) if (a % x == 0 || a % y == 0)) yield a))(_ + _)


  // Problem #2 with recursion

//  Each new term in the Fibonacci sequence is generated by adding the previous two terms.
// By starting with 1 and 2, the first 10 terms will be:
//
//  1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
//
//  By considering the terms in the Fibonacci sequence whose values do not exceed four million,
// find the sum of the even-valued terms.


  // Problem #3 Largest Prime Factor
  // The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143 ?
  def largestPrime(num: Int): Int = {
    def loop(acc: List[Int], rem: List[Int]): Int = {
      val p = rem.head
      val pRange: List[Int] = (p * 2 to num by p).toList
      if (rem.tail.isEmpty) rem.head
      else loop(p :: acc, rem.tail.filterNot(pRange.contains(_)))
    }
    loop(Nil, (2 to num).toList)
  }

  def isBigPrime(number: BigInt): Boolean = {
    def loop(i: BigInt, ceiling: BigInt): Boolean =
      if (i > ceiling) true
      else if (number % i == 0) false
      else loop(i+1, ceiling)
    if (number < 0) false
    else if (number < 2) true
    else loop(2, math.sqrt(number.doubleValue()).toInt)
  }

  def nextBigPrime(n: BigInt): BigInt =
    if (isBigPrime(n+1)) n+1
    else nextBigPrime(n+1)

  def largestPrimeFactor(number: BigInt): BigInt = {
    def loop(i: BigInt, lpf: BigInt, rem: BigInt): BigInt = {
      if (i > rem) lpf
      else if (rem % i == 0) loop(i, i, rem / i)
      else loop(nextBigPrime(i), lpf, rem)
    }
    if (number < 2) 1 else loop(2, 0, number)
  }

  def isPrime(number: Int): Boolean = {
    def loop(i: Int, ceiling: Int): Boolean =
      if (i > ceiling) true
      else if (number % i == 0) false
      else loop(i+1, ceiling)
    if (number < 0) false
    else if (number < 2) true
    else loop(2, math.sqrt(number.doubleValue()).toInt)
  }

  def nextPrime(n: Int): Int =
    if (isPrime(n+1)) n+1
    else nextPrime(n+1)

  def primeFactors(number: Int): List[Int] = {
    def loop(i: Int, acc: List[Int], rem: Int): List[Int] =
      if (i > rem) acc
      else if (rem % i == 0) loop(i, i :: acc, rem / i)
      else loop(nextPrime(i), acc, rem)
    if (number < 0) Nil
    else if (number == 0) List(0)
    else if (number == 1) List(1)
    else loop(2, List(), number)
  }

  // Problem #4 Largest palindrome product
  // Find the largest palindrome made from the product of two 3-digit numbers.
  def isPalindrome(n: Int): Boolean = {
    def loop(s: List[Char]): Boolean = {
      if (s.isEmpty || s.tail.isEmpty) true
      else if (s.head == s.last) loop(s.tail.reverse.tail)
      else false
    }
    loop(n.toString.toList)
  }

  def getMaxPalindromeProductOfXY(floor: Int, ceiling: Int): Int = {
    def loop(x: Int, y: Int): List[Int] = {
      if (x == floor || y == floor) Nil
      else (x * y) :: loop(x - 1, y) ::: loop(x, y - 1) ::: loop(x - 1, y - 1)
    }
    val acc = loop(ceiling, ceiling).filter(isPalindrome(_))
    if (acc.isEmpty) 0 else acc.max
  }

  def largestPalindromeProduct(ceiling: Int): Int = {
    def loop(acc: List[Int], n: Int): Int = {
      if (n < 900) acc.max
      else if (ceiling > 10) loop(getMaxPalindromeProductOfXY(n - 100, n) :: acc, n - 100)
      else loop(getMaxPalindromeProductOfXY(0, n) :: acc, 100 - n)
    }
    loop (List(0), ceiling)
  }

  def nextPalindrome(n: Int): Int = if (isPalindrome(n+1)) n+1 else nextPalindrome(n+1)

  def getPalindromeRange(floor: Int, ceiling: Int): List[Int] = {
    def loop(n: Int, acc: List[Int]): List[Int] =
      if (n > ceiling) acc
      else loop(nextPalindrome(n), nextPalindrome(n) :: acc)
    loop(floor, List())
  }

  val threeDigitNumbers = (100 to 999).toList

  def maxPalindromeProduct(numbers: List[Int]) = {
    val palindromes =
      for {
        a <- numbers
        b <- numbers
        value = a * b
        if (value.toString == value.toString.reverse)
      } yield value
    palindromes.max
  }





}